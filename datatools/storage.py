"""Storege for data with connected metadata"""

import hashlib
import json
import logging
import os
from dataclasses import dataclass
from functools import cached_property
from io import BytesIO, IOBase
from pathlib import Path
from typing import Callable, Iterable, Literal, Optional, Union, cast

from datatools.classes import (
    Any,
    MetadataKey,
    MetadataValue,
    ResourceName,
    StorageException,
    Type,
)
from datatools.process import Converter
from datatools.utils import (
    cache,
    get_filetype_from_filename,
    get_keyword_only_parameters_types,
    get_type_name,
    json_serialize,
    jsonpath_get,
    jsonpath_update,
    passthrough,
)

__all__ = ["Storage", "Resource"]

METADATA_DATATYPE = "datatype"
METADATA_FILETYPE = "filetype"


@dataclass(frozen=True)
class Storage:
    location: str

    __metadata_suffix = ".metadata.json"

    @cache
    def get_valid_resource_name(self, name: ResourceName) -> ResourceName:
        """Validate resource name, if not valid, raise exception."""
        return name

    @cache
    def ressource(self, name: ResourceName) -> "Resource":
        """Return resource for given name. Path might be changed

        Parameters
        ----------
        name : ResourceName
            unique resource name ins storage

        Returns
        -------
        Resource
        """
        name = self.get_valid_resource_name(name)
        return Resource(self, name)

    def write(
        self, data: IOBase, suffix: str = "", hashtype: Literal["md5", "sha256"] = "md5"
    ) -> "Resource":
        """Return resource, name will be generated by hashsum, data will be saved.

        Parameters
        ----------
        data : IOBase
            Binary data stream
        suffix : str, optional
            prefix for file name, by default ""
        hashtype : Literal['md5', 'sha256'], optional
            hashing method, by default "md5"

        Returns
        -------
        Resource
        """

        bdata = data.read()
        hashsum = getattr(hashlib, hashtype)(bdata).hexdigest()
        name = f"{hashtype}/{hashsum}{suffix}"
        resource = self.ressource(name)
        data = BytesIO(bdata)
        resource.write(data)
        return resource

    def list(self, **filters) -> Iterable["Resource"]:
        """Iterate over resources in storage (optionally implemented filters)

        Parameters
        ----------
        **filters : dict, optional
            Additional settings to filter resources, depends on implementation.

        Returns
        -------
        Iterable of Resource
        """
        if not os.path.exists(self.location):
            return None
        for rt, _ds, fs in os.walk(self.location):
            for f in fs:
                # only find metadata
                if not f.endswith(self.__metadata_suffix):
                    continue
                offset = -len(self.__metadata_suffix)
                f = f[:offset]
                name = self.__get_path(Path(os.path.join(rt, f)))
                resource = self.ressource(name)
                yield resource

    def _has_data(self, name: ResourceName) -> bool:
        """Check if resource has data stored (Metadata will be ignored).

        Parameters
        ----------
        name : ResourceName
            unique resource name ins storage

        Returns
        -------
        bool
        """
        return self.__get_filepath(name).exists()

    def _open(self, name: ResourceName) -> IOBase:
        """Open binary data stream for resource.

        Parameters
        ----------
        name : ResourceName
            unique resource name ins storage

        Returns
        -------
        IOBase
            Binary data stream
        """

        filepath = self.__get_filepath(name)
        logging.debug("opening rb: %s", filepath)
        return open(filepath, "rb")

    def _write(self, name: ResourceName, data: IOBase) -> None:
        """Write resource data.

        Parameters
        ----------
        name : ResourceName
            unique resource name ins storage
        data : IOBase
            Binary data stream
        """
        filepath = self.__get_filepath(name)
        if filepath.exists():
            raise StorageException("Resource exists")
        with self.__open_write(filepath) as file:
            # TODO: wrap into byte iterator
            for chunk in data:
                file.write(chunk)

    def _delete(self, name: ResourceName) -> None:
        """Delete resource's data (and metadata).

        Parameters
        ----------
        name : ResourceName
            unique resource name ins storage
        """
        for filepath in [self.__get_filepath(name), self.__get_filepath_metadata(name)]:
            if filepath.exists():
                filepath.unlink()

    def _metadata_set(self, name: ResourceName, **key_vals) -> None:
        """Set (mutliple) metadata entries for resource.

        Parameters
        ----------
        name : ResourceName
            unique resource name ins storage
        **key_vals : dict
            key value pars of metadata
        """
        filepath_meta = self.__get_filepath_metadata(name)
        metadata = self.__metadata_read(filepath_meta)
        # update metadata
        for key, val in key_vals.items():
            jsonpath_update(metadata, key, val)

        data = json.dumps(
            metadata, indent=2, ensure_ascii=False, default=json_serialize
        ).encode()
        with self.__open_write(filepath_meta) as file:
            file.write(data)

    def _metadata_get(
        self, name: ResourceName, key: Union[MetadataKey, Iterable[MetadataKey]]
    ) -> Union[MetadataValue, dict[MetadataKey, MetadataValue]]:
        """Get metadata entry for resource.

        Parameters
        ----------
        name : ResourceName
            unique resource name ins storage
        key : MetadataKey
            metadata key

        Returns
        -------
        MetadataValue
            metadata value
        """
        filepath_meta = self.__get_filepath_metadata(name)
        metadata = self.__metadata_read(filepath_meta)

        # get results via jsonpath
        if isinstance(key, MetadataKey):
            return jsonpath_get(metadata, key)
        elif isinstance(key, list):
            return {k: jsonpath_get(metadata, k) for k in key}
        else:
            raise TypeError(
                f"key must be MetadataKey or list of MetadataKey, got {type(key)}"
            )

    @cache
    def __get_filepath(self, name: ResourceName) -> Path:
        # TODO: ensure its a proper name inside of storage locacion
        # file must contain "." and suffix
        return Path(self.location) / name

    @cache
    def __get_path(self, filepath: Path) -> ResourceName:
        return filepath.absolute().relative_to(self.location).as_posix()

    @cache
    def __get_filepath_metadata(self, name: ResourceName) -> Path:
        filepath = self.__get_filepath(name)
        return filepath.parent / f"{filepath.name}{self.__metadata_suffix}"

    def __open_write(self, filepath: Path) -> IOBase:
        filepath.parent.mkdir(exist_ok=True, parents=True)
        logging.debug("opening wb: %s", filepath)
        return open(filepath, "wb")

    def __metadata_read(self, filepath_meta: Path) -> dict:
        if not filepath_meta.exists():
            return {}
        with filepath_meta.open(encoding="utf-8") as file:
            return json.load(file)


@dataclass(frozen=True)
class Resource:
    """Proxy object of stored data (and metadata)."""

    storage: "Storage"
    name: ResourceName

    def exist(self) -> bool:
        """Check if resource has data stored (metadata will be ignored).

        Returns
        -------
        bool
            True if data for resource exists.
        """
        return self.storage._has_data(self.name)

    def open(self) -> IOBase:
        """Open binary data stream for resource.

        Returns
        -------
        IOBase
            Binary data stream
        """
        return self.storage._open(self.name)

    def write(self, data: IOBase) -> None:
        """Write resource data.

        Parameters
        ----------
        data : IOBase
            Binary data stream

        """
        return self.storage._write(self.name, data)

    def delete(self) -> None:
        """Delete resource's data (and metadata)."""
        return self.storage._delete(self.name)

    @cached_property
    def metadata(self) -> "Metadata":
        """Get metadata interface resource.

        Returns
        -------
        Metadata
        """
        return Metadata(self)

    def _get_filetype(self) -> Type:
        return cast(
            str, self.metadata.get(METADATA_FILETYPE)
        ) or get_filetype_from_filename(self.name)

    def get_loader(self, type_to: Type) -> Callable:
        filetype = self._get_filetype()
        convert = Converter.get(type_from=filetype, type_to=type_to)

        # get optional parameter names for convert
        # min_idx = 1: skip first parameter (data)
        optional_param_names = get_keyword_only_parameters_types(convert, min_idx=1)
        # try to get these from metadata (if they exist)
        optional_kwargs = {
            k: v
            for k, v in self.metadata.get(optional_param_names).items()
            if v is not None
        }

        def loader(**kwargs):
            # user kwargs have higher priority than metadata
            kwargs = optional_kwargs | kwargs

            with self.open() as file:
                return convert(file, **kwargs)

        return loader

    def get_dumper(self, type_from: Type) -> Callable:
        filetype = self._get_filetype()
        # get converter if type_from is not byte like
        # TODO:
        if get_type_name(type_from) in {get_type_name(BytesIO)}:
            convert = passthrough
        else:
            convert = Converter.get(type_from=type_from, type_to=filetype)

        try:
            get_metadata = Converter.get(type_from=type_from, type_to=Metadata)
        except KeyError:
            get_metadata = None

        # get optional parameter names for convert
        # min_idx = 2: skip first 2 parameter (data, metadata)
        optional_param_names = get_keyword_only_parameters_types(convert, min_idx=2)
        # try to get these from metadata (if they exist)
        optional_kwargs = {
            k: v
            for k, v in self.metadata.get(optional_param_names).items()
            if v is not None
        }

        def writer(data, metadata=None, **kwargs):
            # user kwargs have higher priority than metadata
            kwargs = optional_kwargs | kwargs
            metadata = (metadata or {}) | kwargs
            if get_metadata:
                # get metadata from data
                metadata = get_metadata(data) | metadata

            # write metadata
            if metadata:
                self.metadata.set(**metadata)

            # TODO get byte metadata (size, hash)
            self.write(convert(data, **kwargs))

        return writer

    def load(self, **kwargs) -> Any:
        datatype = cast(str, self.metadata.get(METADATA_DATATYPE))
        loader = self.get_loader(type_to=datatype)
        data = loader(**kwargs)
        return data

    def dump(self, data: Any, metadata: Optional[dict] = None, **kwargs) -> None:
        datatype = cast(str, self.metadata.get(METADATA_DATATYPE) or type(data))
        writer = self.get_dumper(type_from=datatype)
        # update metadata
        metadata = {METADATA_DATATYPE: datatype} | kwargs | (metadata or {})
        writer(data, metadata, **kwargs)


@dataclass(frozen=True)
class Metadata:
    """Interface to get/set metadata."""

    resource: Resource

    def get(
        self, key: Union[MetadataKey, Iterable[MetadataKey]]
    ) -> Union[MetadataValue, dict[MetadataKey, MetadataValue]]:
        """Get metadata entry for resource.

        Parameters
        ----------
        key : MetadataKey
            metadata key

        Returns
        -------
        MetadataValue
            metadata value
        """
        return self.resource.storage._metadata_get(self.resource.name, key)

    def set(self, **key_vals) -> None:
        """Set (mutliple) metadata entries for resource.

        Parameters
        ----------
        **key_vals : dict
            key value pars of metadata
        """
        return self.resource.storage._metadata_set(self.resource.name, **key_vals)
