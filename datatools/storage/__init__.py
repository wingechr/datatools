import hashlib
import json
import os
from dataclasses import dataclass
from functools import cached_property
from io import BytesIO, IOBase
from pathlib import Path
from typing import Any, Iterable

from datatools.utils import cache


class StorageException(Exception):
    pass


ResourcePath = str
MetadataKey = str
MetadataValue = Any


@dataclass(frozen=True)
class AbstractStorage:

    location: str

    def get(self, path: ResourcePath) -> "Resource":
        """Return resource for given path. Path might be changed"""
        raise NotImplementedError()

    def store(
        self, data: IOBase, suffix: str = "", hashtype: str = "md5"
    ) -> "Resource":
        """Return resource, path will be generated by hashsum, data will be saved."""
        raise NotImplementedError()

    def list(self, **filters) -> Iterable["Resource"]:
        """Iterate over resources in storage (optionally implemented filters)"""
        raise NotImplementedError()

    def _has_data(self, path: ResourcePath) -> bool:
        """Check if resource has data stored (Metadata will be ignored)."""
        raise NotImplementedError()

    def _open(self, path: ResourcePath) -> IOBase:
        """Open binary data stream for resource."""
        raise NotImplementedError()

    def _delete(self, path: ResourcePath, keep_metadata: bool = False) -> None:
        """Delete resource's data (and metadata)."""
        raise NotImplementedError()

    def _write(self, path: ResourcePath, data: IOBase) -> None:
        """Write resource data."""
        raise NotImplementedError()

    def _metadata_set(self, path: ResourcePath, **key_vals) -> None:
        """Set (mutliple) metadata entries for resource."""
        raise NotImplementedError()

    def _metadata_get(self, path: ResourcePath, key: MetadataKey) -> MetadataValue:
        """Get metadata entry for resource."""
        raise NotImplementedError()


class Storage(AbstractStorage):
    location: str

    __metadata_suffix = ".metadata.json"

    @cache
    def get(self, path: ResourcePath) -> "Resource":
        # TODO: validate path?
        return Resource(self, path)

    def _has_data(self, path: ResourcePath) -> bool:
        return self.__get_filepath(path).exists()

    def _open(self, path: ResourcePath) -> IOBase:
        return open(self.__get_filepath(path), "rb")

    def _write(self, path: ResourcePath, data: IOBase) -> None:
        filepath = self.__get_filepath(path)
        with self.__open_write(filepath) as file:
            file.write(data.read())

    def list(self, **filters) -> Iterable["Resource"]:
        if not os.path.exists(self.location):
            return None
        for rt, _ds, fs in os.walk(self.location):
            for f in fs:
                # only find metadata
                if not f.endswith(self.__metadata_suffix):
                    continue
                offset = -len(self.__metadata_suffix) - 1
                f = f[:offset]
                path = self.__get_path(Path(os.path.join(rt, f)))
                resource = self.get(path)
                yield resource

    def _delete(self, path: ResourcePath, keep_metadata: bool = False) -> None:
        filepath = self.__get_filepath(path)
        # data might not exist
        if filepath.exists():
            filepath.unlink()
        if not keep_metadata:
            filepath_meta = self.__get_filepath_metadata(path)
            filepath_meta.unlink()

    def _metadata_set(self, path: ResourcePath, **key_vals) -> None:
        filepath_meta = self.__get_filepath_metadata(path)
        metadata = self.__metadata_read(filepath_meta)
        # update metadata
        metadata = metadata | key_vals
        data = json.dumps(metadata, indent=2, ensure_ascii=False).encode()
        with self.__open_write(filepath_meta) as file:
            file.write(data)

    def _metadata_get(self, path: ResourcePath, key: MetadataKey) -> MetadataValue:
        filepath_meta = self.__get_filepath_metadata(path)
        metadata = self.__metadata_read(filepath_meta)
        return metadata.get(key)

    def store(
        self, data: IOBase, suffix: str = "", hashtype: str = "md5"
    ) -> "Resource":
        # create hash
        bdata = data.read()
        hashsum = getattr(hashlib, hashtype)(bdata).hexdigest()
        path = f"{hashtype}/{hashsum}{suffix}"
        resource = self.get(path)
        data = BytesIO(bdata)
        resource.write(data)
        return resource

    @cache
    def __get_filepath(self, path: ResourcePath) -> Path:
        # TODO: ensure its a proper path inside of storage locacion
        # folders in path must not contain "."
        # file must contain "." and suffix
        return Path(self.location) / path

    @cache
    def __get_path(self, filepath: Path) -> ResourcePath:
        return filepath.absolute().relative_to(self.location).as_posix()

    @cache
    def __get_filepath_metadata(self, path: ResourcePath) -> Path:
        filepath = self.__get_filepath(path)
        return filepath.parent / f"{filepath.name}.{self.__metadata_suffix}"

    def __open_write(self, filepath: Path) -> IOBase:
        filepath.parent.mkdir(exist_ok=True, parents=True)
        return open(filepath, "wb")

    def __metadata_read(self, filepath_meta: Path) -> dict:
        if not filepath_meta.exists():
            return {}
        with filepath_meta.open(encoding="utf-8") as file:
            return json.load(file)


@dataclass(frozen=True)
class Resource:
    storage: "Storage"
    path: ResourcePath

    def exist(self) -> bool:
        """Check if resource has data stored (Metadata will be ignored)."""
        return self.storage._has_data(self.path)

    def open(self) -> IOBase:
        """Open binary data stream for resource."""
        return self.storage._open(self.path)

    def write(self, data: IOBase) -> None:
        """Write resource data."""
        return self.storage._write(self.path, data)

    def delete(self, keep_metadata: bool = False) -> None:
        """Delete resource's data (and metadata)."""
        return self.storage._delete(self.path, keep_metadata=keep_metadata)

    @cached_property
    def metadata(self) -> "Metadata":
        return Metadata(self)


@dataclass(frozen=True)
class Metadata:
    resource: Resource

    def get(self, key: MetadataKey) -> MetadataValue:
        """Get metadata entry for resource."""
        return self.resource.storage._metadata_get(self.resource.path, key)

    def set(self, **key_vals) -> None:
        """Set (mutliple) metadata entries for resource."""
        return self.resource.storage._metadata_set(self.resource.path, **key_vals)


__all__ = ["Storage", "Resource"]
