"""Storege for data with connected metadata"""

import hashlib
import json
import os
from dataclasses import dataclass
from functools import cached_property
from io import BytesIO, IOBase
from pathlib import Path
from typing import Any, Iterable, Literal

# from datatools.utils import cache

__all__ = ["Storage", "Resource", "StorageException"]

ResourcePath = str
MetadataKey = str
MetadataValue = Any


class StorageException(Exception):
    pass


class InvalidPathException(StorageException):
    pass


@dataclass(frozen=True)
class Storage:
    location: str

    __metadata_suffix = ".metadata.json"

    # @cache

    def get(self, path: ResourcePath) -> "Resource":
        """Return resource for given path. Path might be changed

        Parameters
        ----------
        path : ResourcePath
            unique resource path ins storage

        Returns
        -------
        Resource
        """
        # TODO: validate path?
        return Resource(self, path)

    def write(
        self, data: IOBase, suffix: str = "", hashtype: Literal["md5", "sha256"] = "md5"
    ) -> "Resource":
        """Return resource, path will be generated by hashsum, data will be saved.

        Parameters
        ----------
        data : IOBase
            Binary data stream
        suffix : str, optional
            prefix for file name, by default ""
        hashtype : Literal['md5', 'sha256'], optional
            hashing method, by default "md5"

        Returns
        -------
        Resource
        """

        bdata = data.read()
        hashsum = getattr(hashlib, hashtype)(bdata).hexdigest()
        path = f"{hashtype}/{hashsum}{suffix}"
        resource = self.get(path)
        data = BytesIO(bdata)
        resource.write(data)
        return resource

    def list(self, **filters) -> Iterable["Resource"]:
        """Iterate over resources in storage (optionally implemented filters)

        Parameters
        ----------
        **filters : dict, optional
            Additional settings to filter resources, depends on implementation.

        Returns
        -------
        Iterable of Resource
        """
        if not os.path.exists(self.location):
            return None
        for rt, _ds, fs in os.walk(self.location):
            for f in fs:
                # only find metadata
                if not f.endswith(self.__metadata_suffix):
                    continue
                offset = -len(self.__metadata_suffix) - 1
                f = f[:offset]
                path = self.__get_path(Path(os.path.join(rt, f)))
                resource = self.get(path)
                yield resource

    def _has_data(self, path: ResourcePath) -> bool:
        """Check if resource has data stored (Metadata will be ignored).

        Parameters
        ----------
        path : ResourcePath
            unique resource path ins storage

        Returns
        -------
        bool
        """
        return self.__get_filepath(path).exists()

    def _open(self, path: ResourcePath) -> IOBase:
        """Open binary data stream for resource.

        Parameters
        ----------
        path : ResourcePath
            unique resource path ins storage

        Returns
        -------
        IOBase
            Binary data stream
        """
        return open(self.__get_filepath(path), "rb")

    def _write(self, path: ResourcePath, data: IOBase) -> None:
        """Write resource data.

        Parameters
        ----------
        path : ResourcePath
            unique resource path ins storage
        data : IOBase
            Binary data stream
        """
        filepath = self.__get_filepath(path)
        with self.__open_write(filepath) as file:
            file.write(data.read())

    def _delete(self, path: ResourcePath) -> None:
        """Delete resource's data (and metadata).

        Parameters
        ----------
        path : ResourcePath
            unique resource path ins storage
        """
        for filepath in [self.__get_filepath(path), self.__get_filepath_metadata(path)]:
            if filepath.exists():
                filepath.unlink()

    def _metadata_set(self, path: ResourcePath, **key_vals) -> None:
        """Set (mutliple) metadata entries for resource.

        Parameters
        ----------
        path : ResourcePath
            unique resource path ins storage
        **key_vals : dict
            key value pars of metadata
        """
        filepath_meta = self.__get_filepath_metadata(path)
        metadata = self.__metadata_read(filepath_meta)
        # update metadata
        metadata = metadata | key_vals
        data = json.dumps(metadata, indent=2, ensure_ascii=False).encode()
        with self.__open_write(filepath_meta) as file:
            file.write(data)

    def _metadata_get(self, path: ResourcePath, key: MetadataKey) -> MetadataValue:
        """Get metadata entry for resource.

        Parameters
        ----------
        path : ResourcePath
            unique resource path ins storage
        key : MetadataKey
            metadata key

        Returns
        -------
        MetadataValue
            metadata value
        """
        filepath_meta = self.__get_filepath_metadata(path)
        metadata = self.__metadata_read(filepath_meta)
        return metadata.get(key)

    # @cache
    def __get_filepath(self, path: ResourcePath) -> Path:
        # TODO: ensure its a proper path inside of storage locacion
        # folders in path must not contain "."
        # file must contain "." and suffix
        return Path(self.location) / path

    # @cache
    def __get_path(self, filepath: Path) -> ResourcePath:
        return filepath.absolute().relative_to(self.location).as_posix()

    # @cache
    def __get_filepath_metadata(self, path: ResourcePath) -> Path:
        filepath = self.__get_filepath(path)
        return filepath.parent / f"{filepath.name}.{self.__metadata_suffix}"

    def __open_write(self, filepath: Path) -> IOBase:
        filepath.parent.mkdir(exist_ok=True, parents=True)
        return open(filepath, "wb")

    def __metadata_read(self, filepath_meta: Path) -> dict:
        if not filepath_meta.exists():
            return {}
        with filepath_meta.open(encoding="utf-8") as file:
            return json.load(file)


@dataclass(frozen=True)
class Resource:
    """Proxy object of stored data (and metadata)."""

    storage: "Storage"
    path: ResourcePath

    def exist(self) -> bool:
        """Check if resource has data stored (metadata will be ignored).

        Returns
        -------
        bool
            True if data for resource exists.
        """
        return self.storage._has_data(self.path)

    def open(self) -> IOBase:
        """Open binary data stream for resource.

        Returns
        -------
        IOBase
            Binary data stream
        """
        return self.storage._open(self.path)

    def write(self, data: IOBase) -> None:
        """Write resource data.

        Parameters
        ----------
        data : IOBase
            Binary data stream

        """
        return self.storage._write(self.path, data)

    def delete(self) -> None:
        """Delete resource's data (and metadata)."""
        return self.storage._delete(self.path)

    @cached_property
    def metadata(self) -> "Metadata":
        """Get metadata interface resource.

        Returns
        -------
        Metadata
        """
        return Metadata(self)


@dataclass(frozen=True)
class Metadata:
    """Interface to get/set metadata."""

    resource: Resource

    def get(self, key: MetadataKey) -> MetadataValue:
        """Get metadata entry for resource.

        Parameters
        ----------
        key : MetadataKey
            metadata key

        Returns
        -------
        MetadataValue
            metadata value
        """
        return self.resource.storage._metadata_get(self.resource.path, key)

    def set(self, **key_vals) -> None:
        """Set (mutliple) metadata entries for resource.

        Parameters
        ----------
        **key_vals : dict
            key value pars of metadata
        """
        return self.resource.storage._metadata_set(self.resource.path, **key_vals)
